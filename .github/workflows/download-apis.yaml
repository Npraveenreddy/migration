name: Download and Deploy APIs via SSM

on:
  workflow_dispatch:
    inputs:
      apiFolder:
        description: 'API folder to download (or "all")'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - AHS.GC.Web
          - AHS.GC.authorizationportal
          - AHS.GC.ConfigAPI
          - AHS.GC.SmartComm
          - AHS.GC.Cloud
      cloudApi:
        description: 'Specific Cloud API to download (or "all")'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - account
          - activity
          - admin
          - assessments
          - master
          - member

jobs:
  download-and-deploy:
    runs-on: ubuntu-latest
    env:
      RELEASE_REPO: Npraveenreddy/artifacts
      RELEASE_TAG: v8.17.2025.08_RC1
      GH_TOKEN: ${{ secrets.ARTIFACTS_PAT }}

    steps:
    - name: ‚úÖ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: üì• Download and prepare artifacts
      run: |
        mkdir extracted
        echo $GH_TOKEN | gh auth login --with-token
        RELEASE_TAG="${{ env.RELEASE_TAG }}"
        REPO="${{ env.RELEASE_REPO }}"
        API_FOLDER="${{ github.event.inputs.apiFolder }}"
        CLOUD_API="${{ github.event.inputs.cloudApi }}"

        topLevelApis=("AHS.GC.Web" "AHS.GC.authorizationportal" "AHS.GC.ConfigAPI" "AHS.GC.SmartComm" "AHS.GC.Cloud")
        cloudSubApis=("account" "activity" "admin" "assessments" "master" "member")

        selected=()

        if [[ "$API_FOLDER" == "all" ]]; then
          for api in "${topLevelApis[@]}"; do
            [[ "$api" != "AHS.GC.Cloud" ]] && selected+=("$api")
          done
        elif [[ "$API_FOLDER" != "AHS.GC.Cloud" ]]; then
          selected+=("$API_FOLDER")
        fi

        if [[ "$CLOUD_API" == "all" ]]; then
          selected+=("${cloudSubApis[@]}")
        elif [[ "$CLOUD_API" != "" ]]; then
          selected+=("$CLOUD_API")
        fi

        for name in "${selected[@]}"; do
          echo "‚¨áÔ∏è Downloading $name.zip"
          gh release download "$RELEASE_TAG" --repo "$REPO" --pattern "$name.zip" --dir .
          unzip -o "$name.zip" -d "extracted/$name"
          zip -r "$name-compressed.zip" "extracted/$name"
          base64 "$name-compressed.zip" > "$name.b64"
        done

    - name: üöÄ Deploy to EC2 via SSM
      run: |
        for file in *.b64; do
          name=$(basename "$file" .b64)
          content=$(cat "$file" | tr -d '\n')

          aws ssm send-command \
            --document-name "AWS-RunPowerShellScript" \
            --targets "Key=instanceIds,Values=i-0409b449dd184132b" \
            --comment "Deploy $name via SSM" \
            --parameters "commands=[
              \"\$b64 = '$content'\",
              \"\$bytes = [System.Convert]::FromBase64String(\$b64)\",
              \"\$zipPath = 'C:\\temp\\$name.zip'\",
              \"[System.IO.File]::WriteAllBytes(\$zipPath, \$bytes)\",
              \"Expand-Archive -Path \$zipPath -DestinationPath 'C:\\temp\\$name' -Force\",
              \"\$map = @{
                'AHS.GC.Web' = 'Portal';
                'AHS.GC.authorizationportal' = 'AuthorizationPortal';
                'AHS.GC.ConfigAPI' = 'CONFIGAPI';
                'AHS.GC.SmartComm' = 'SmartCommAPI';
                'account' = 'CloudAPI';
                'activity' = 'CloudAPI';
                'admin' = 'CloudAPI';
                'assessments' = 'CloudAPI';
                'master' = 'CloudAPI';
                'member' = 'CloudAPI'
              }\",
              \"if (\$map.ContainsKey('$name')) {
                robocopy 'C:\\temp\\$name' 'C:\\inetpub\\wwwroot\\Deployment\\GITHUB\\' + \$map['$name'] /MIR /NFL /NDL /NJH /NJS /NC /NS
              } else {
                Write-Host '‚ö†Ô∏è No target folder mapped for $name'
              }\"
            ]" \
            --output text
